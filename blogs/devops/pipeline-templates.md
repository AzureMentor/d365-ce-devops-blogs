# Modularizing Pipelines and Implementing PowerApps Checker in DevOps for Dynamics 365 for Customer Engagement Solutions

Welcome to the next entry in our blog series on DevOps for Dynamics 365 for Customer Engagement (D365 CE). Up until now, we've covered the following:

- [Introduction to DevOps for Dynamics 365 Customer Engagement using YAML Based Azure Pipelines](https://community.dynamics.com/crm/b/crminthefield/archive/2019/02/27/introduction-to-devops-for-dynamics-365-customer-engagement-using-yaml-based-azure-pipelines)
    - Unpack PowerApps solutions into source control.
    - Use YAML pipelines to pack solutions and import them into a target environment.
    - [Introduction to DevOps for Dynamics 365 Customer Engagement using YAML Based Azure Pipelines - Part 1.5](https://community.dynamics.com/crm/b/crminthefield/archive/2019/05/09/introduction-to-devops-for-dynamics-365-customer-engagement-using-yaml-based-azure-pipelines-part-1-5)
        - Take advantage of the [new multi-stage YAML pipelines](https://mybuild.techcommunity.microsoft.com/sessions/77791?source=sessions#top-anchor) in Azure DevOps to break our pipeline into logical stages.
        - Download build artifacts for the deployment stage of our pipeline.

This article will build on the material covered so far, so if you want to follow along and you haven't walked through those articles yet, I'd recommend you do so.

## Contents

- [Introduction](#introduction)
- [Making Pipelines Reusable](#making-pipelines-reusable)
  - [Introducing Job Templates](#introducing-job-templates)
  - [Referencing a Pipeline Repository From a Pipeline](#referencing-a-pipeline-repository-from-a-pipeline)
- [Include PowerApps Checker in a Pipeline](#include-powerapps-checker-in-a-pipeline)

## Introduction

Often times in large development efforts, a codebase will rapidly approach a critical, messy mass where additional features become exponentially more difficult to implement. The developers' impulse here may be to stop all new feature development and redesign the entire system, but [this is never a good idea](http://www.luckymethod.com/2013/03/the-big-redesign-in-the-sky/). Instead, we need to start making iterative changes to our code to clean it as we add new features. In this article, we are going to be celebrating this philosophy.

As a new deliverable in our DevOps environment, we will be enforcing some code quality rules by including [PowerApps Checker](#TODO: add link) in the build stage of our pipeline. We can consume the results of the report generated by this module to prevent developers from introducing common D365 CE anti-patterns to our codebase.

## Making Pipelines Reusable

It is very likely your D365 CE deployment will consist of more than one solution. While the components that comprise your solution may be distinct, the pipelines you use to deploy these solutions will be quite similar, if not completely identical. That said, it would be an ironic shame if we were to start copying and pasting our code while implementing *DevOps*.

There are many strategies for organizing your D365 CE solution architecture in source control. We will be exploring some of them in later blog posts, but for the purposes for this article, let's assume that we've landed on a strategy which includes us storing our pipeline templates in a separate repository. You can import/fork [our pipeline repository](https://github.com/microsoft-d365-ce-pfe-devops/D365-CE-Pipelines), or create your own.

### Introducing Stage Templates

[Stage templates](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema#stage-templates) let us write the YAML for our stages in separate files, enabling us to gain the power of new multi-stage pipelines combined with the cleanliness of modularity. At the time of writing this article, there are templates for stages, jobs, steps, and variables. Eventually, we will be using each of them, but for now, we'll start with stage templates, leaving the world a little cleaner than when we found it.

```YAML
stages:
- stage: Build
  jobs:
    - job:
      displayName: "Pack Solution from repository"
```
*Excerpt from [stages/build.yml](https://github.com/microsoft-d365-ce-pfe-devops/D365-CE-Pipelines/blob/master/stages/build.yml)*

For the full source code of the stage template, click the link above. Since we're planning on using other template types here, let's think ahead a little bit and place our stage templates in a folder. Of course, the eventual increasing complexity of this project may call for that to change.

```YAML
stages:
- stage: Release

  dependsOn: Build
  condition: succeeded('Build')

  jobs:
  - deployment: Deploy
    displayName: "Import solution artifact"
```
*Excerpt from [stages/release.yml](https://github.com/microsoft-d365-ce-pfe-devops/D365-CE-Pipelines/blob/master/stages/release.yml)*

#TODO: Add some afterthought to these code blocks.

### Referencing a Pipeline Repository From a Pipeline

Since the job template we created is stored in a separate repository, we will need to make available by adding a [repository resource](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema#repository-resource) to our pipeline.

```YAML
name: $(BuildDefinitionName)-$(Date:yyyyMMdd).$(Rev:.r)

trigger:
- master

resources:
  repositories:
    - repository: templates
      type: github
      name: microsoft-d365-ce-pfe-devops/D365-CE-Pipelines
      endpoint: microsoft-d365-ce-devops

jobs:
- template: jobs/pack-import-solution.yml@templates
```
*[pack-import-solution.yml](https://github.com/microsoft-d365-ce-pfe-devops/D365-CE-DevOps-Tutorial/blob/master/Lesson-2/pack-import-solution.yml)*

Note that if you are using an Azure Repo (`type: git`), you will not need to specify an `endpoint`. If you are using GitHub for your repository, you will need to create a service endpoint if you don't have one already.

Now that we've invested some time in making our pipeline code reusable, let's capitalize on our investment and add another pipeline to our belt.

## Include PowerApps Checker in a Pipeline

**TODO**
- Tag Pipeline repository for Lesson 2